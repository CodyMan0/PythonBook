# 문제 풀이

## 럭키 스트레이트

### 문제의 아이디어 생각해낸 포인트

- 파이썬 문법을 활용해보기로 함.

### 시간 복잡도 계산

A. O(N)

### 입력

```py
## 가운데를 기점으로 양 문자열의 합이 같으면 LUCKY 출력 nor READY

# 내풀이
n = int(input())
condition = input()

print(n//2)
left = sum(list(map(int,condition[:n//2])))
right = sum(list(map(int,condition[n//2:])))

if left == right :
print("LUCKY")
else :
print("READY")

    # 책풀이

n = input()
length = len(n)
summary = 0

for i in range(length // 2) :
summary += int(n[i])

for i in range(length // 2, length) :
summary -= int(n[i])

if summary == 0 :
print("LUCKY")
else :
print("READY")
```

## 문자열 재정렬

### 문제의 아이디어 생각해낸 포인트

### 시간 복잡도 계산

### 입력

```py
# n = input()

# a = []
# b = []

# for i in n :
#     if ord(i) > 64 :
#         a.append(i)
#     else :
#         b.append(int(i))
# a.sort()
# b = str(sum(b))

# result = [*a , b]
# result1 = ''.join(result)

# print(result1)


# 책풀이

# data = input()
# result = []
# value = 0

# for x in data :
#     if x.isalpha() :
#         result.append(x)
#     else :
#         value += int(x)

# result.sort()

# if value != 0 :
#     result.append(str(value))

# print(''.join(result))

## isalpha라는 매소드가 있네? 나는 아스키코드로 확인


# 책 풀이를 반영하여 수정한 코드

n = input()

result = []
value = 0

for i in n :
    if i.isalpha() :
        result.append(i)
    else :
        value += int(i)

result.sort()

if value != 0 :
    result.append(str(value))


print(''.join(result))
```

## 문자열 압축

### 문제의 아이디어 생각해낸 포인트

# 아이디어

- 어떻게 해야하는지 막막함.
- 이전 상태 값을 어떻게 기억하고 있게 할지 모르겠음.
- 이전 문자열과 비교해서 count를 증가하고 상태와 동일하면 압축 횟수를 증가시키는게 이번 문자열 압축 문제에서 핵심이라고 생각.

### 시간 복잡도 계산

A. O(n^2)

### 입력

```py
def solution(s):
    answer = len(s)

    for step in range(1,len(s) // 2 + 1) :
        compressed = ''
        prev = s[0 : step]
        count = 1
        ## 단위(count) 크기만큼 증가시키며 이전 문자열과 비교
        for j in range(step, len(s), step) :
        ## 이전 상태와 동일하다면 압축 횟수 증가
            if prev == s[j:j +step] :
                count += 1
            else :
                compressed += str(count) + prev if count >= 2 else prev

                prev = s[j : j + step]
                count = 1
        compressed += str(count) + prev if count >= 2 else prev
        answer = min(answer, len(compressed))

    return answer

s = 'ababcdcdababcdcd'
print(solution(s))## 9
s = "xababcdcdababcdcd"
print(solution(s)) ## 17

```

## 제목

### 문제의 아이디어 생각해낸 포인트

- 파이썬 문법을 활용해보기로 함.

### 시간 복잡도 계산

### 입력

## 제목

### 문제의 아이디어 생각해낸 포인트

- 파이썬 문법을 활용해보기로 함.

### 시간 복잡도 계산

### 입력

## 제목

### 문제의 아이디어 생각해낸 포인트

- 파이썬 문법을 활용해보기로 함.

### 시간 복잡도 계산

### 입력
