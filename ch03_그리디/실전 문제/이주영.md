# 문제 풀이

## 모험가 길드

### 문제의 아이디어 생각해낸 포인트

- 핵심은 정렬, 공포를 오름차순 정렬 , 순서대로 탐색
- 최소한의 인원

### 시간 복잡도 계산

A. O(n)

### 입력

```python
# 2회
## 핵심은 정렬


n = int(input())
array = list(map(int,input().split()))
array.sort()

result = 0
count = 0

print(array)
for horror in array :
    count += 1
    if count >= horror :
        result += 1
        count =0
    print(horror,result,count)

print(result)


```

## 곱하기 혹은 더하기

### 문제의 아이디어 생각해낸 포인트

- 0일 경우에는 더하고 나머지는 곱했다.

### 시간 복잡도 계산

A.O(n)

### 입력

```python
# 내풀이

n = input()

result = 0
for i in n :
    el = int(i)
    if result == 0 :
      result += el
    else :
      result *= el

print(result)


## 책 풀이

data = input()

result = int(data[0])

for i in range(1, len(data)) :
    num = int(data[i])

    if num <= 1 or result <= 1:
        result += num
    else :
        result *= num

## 여기서 핵심은 나는 0일 경우에만 더했는데 문제 정답은 1일 경우에도 더했다.
```

## 문자열 뒤집기

### 문제의 아이디어 생각해낸 포인트

- 처음에는 Split을 활용하였지만 어떻게 해줘야하는지 ...
- 생각보다 안되서 답안지 참고

### 시간 복잡도 계산

### 입력

```py

## 첫번째 풀이

n = input()
result = 0


one = n.split('0')
zero = n.split('1')

print(one)

for i in one :
    if i != '' :
        result += 1

print('one',result)


# 두번째 답지 참고
import sys
s = list(sys.stdin.readline().rstrip())

count0 = 0
count1 = 0

if (s[0] == '0'):
    count0 += 1
else:
    count1 += 1


for i in range(len(s)-1):
    if (s[i] != s[i+1]):
        if (s[i+1] == '0'):
            count0 += 1
        else:
            count1 += 1
# 최솟값
print(min(count0, count1))
```
